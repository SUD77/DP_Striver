


![image](https://user-images.githubusercontent.com/20686188/178293459-be0988f3-1890-4146-97c4-3381e49cee40.png)


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Solution 1: Recursion


public class Solution {
    public static int frogJump(int n, int heights[]) {

        // Write your code here..
 
        return solUtil(n-1,heights);
    }
    
    public static int solUtil(int n,int[] heights){
        
        if(n==0) return 0;
        if(n==1) return Math.abs(heights[1]-heights[0]);
        
        int x= Math.abs((heights[n]-heights[n-1])) + solUtil(n-1,heights);
        int y= Math.abs((heights[n]-heights[n-2]))+ solUtil(n-2,heights);
        
        return Math.min(x,y);
    }

}


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


Solution 2: Memoization




import java.util.Arrays;

public class Solution {
    public static int frogJump(int n, int heights[]) {

        // Write your code here..
        int dp[]=new int[n+1];
        
        Arrays.fill(dp,-1);
 
        solUtil(n-1,heights,dp);
        
        return dp[n-1] ;
    }
    
    public static int solUtil(int n,int[] heights,int[] dp){
        
        if(dp[n]!=-1) return dp[n];
        
        if(n==0) return 0;
        if(n==1) return Math.abs(heights[1]-heights[0]);
        
        dp[0]=0;
        dp[1]=Math.abs(heights[1]-heights[0]);
        
        int x= Math.abs((heights[n]-heights[n-1])) + solUtil(n-1,heights,dp);
        int y= Math.abs((heights[n]-heights[n-2]))+ solUtil(n-2,heights,dp);
        
        return dp[n]=Math.min(x,y);
    }

} 


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Solution 3: Tabulation







