Leetcode Link: https://leetcode.com/problems/target-sum/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Solution 1: Recursion 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Solution 2: Memoization





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MY SOLUTION 
************


Note:
1. In base case, nums[0]=0 is the edge case. Carefully check it. 
2. In this, recursion was accepted in leetcode. 
3. With my current logic for recursion, my intution is that we cant memoize or tabulate it (for my logic). As, for that we have to create a dp array of size [n][target+1]
but in my case, target is going negative too. 
4. Check the recursion tree here : 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Solution 1: Recursion

class Solution {
    public int findTargetSumWays(int[] nums, int target) {
       
        int n=nums.length;
        
        return solUtil(nums,target,n-1);
    }
    
    public int solUtil(int[] nums,int target,int index){
        
        if(index==0) {
         
            if(target-nums[0]==0 || nums[0]+target==0) {
                
                /* Here we are checking this becoz, it might happen we have already reached
                our target, so adding this value i.e 0, will create 2 possiblity. */
                
                if(nums[0]==0) return 2;
                return 1;
            }
            else return 0;
        }
 
        
        int add=solUtil(nums,target+nums[index],index-1);
        
        int sub=solUtil(nums,target-nums[index],index-1);
        
        
        return add+sub;
    }
}



