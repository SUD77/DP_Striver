
LeetLink : https://leetcode.com/problems/minimum-path-sum/






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*************************************
Solution 1: Recursion (will give TLE)
*************************************

***********************************************************************************************************************************************************



***********************************************************************************************************************************************************

class Solution {
    public int minPathSum(int[][] grid) {
        
        
        int m=grid.length;
        int n=grid[0].length;
        
        return solUtil(m,n,grid,0,0);
    }
    
    public int solUtil(int m,int n, int[][] nums,int i,int j){
        
        if(i>=m || j>=n) return Integer.MAX_VALUE;
        if(i==m-1 && j==n-1) return nums[i][j];
        
        int currVal=nums[i][j];
        int result=0;
        
        int down=solUtil(m,n,nums,i+1,j);
        int right=solUtil(m,n,nums,i,j+1);
        
        
        result=currVal+Math.min(down,right);
        
        return result;
        
        
    }
}








////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*************************************
Solution 2: Memoization
*************************************

***********************************************************************************************************************************************************

Time Complexity: O(N*M)
Space Complexity: O((M-1)+(N-1)) + O(N*M)

***********************************************************************************************************************************************************


class Solution {
    public int minPathSum(int[][] grid) {
        
   
        int m=grid.length;
        int n=grid[0].length;
        
        int dp[][]=new int[m][n];
        
        for(int[] x:dp){
            Arrays.fill(x,-1);
        }
        
        
        solUtil(m,n,grid,0,0,dp);
        
        return dp[0][0];
    }
    
    public int solUtil(int m,int n, int[][] nums,int i,int j,int[][] dp){
        
        if(i>=m || j>=n) return Integer.MAX_VALUE;
        
        if(dp[i][j]!=-1) return dp[i][j];
        
        
        if(i==m-1 && j==n-1) return dp[i][j]=nums[i][j];
        
        int currVal=nums[i][j];
        int result=0;
        
        int down=solUtil(m,n,nums,i+1,j,dp);
        int right=solUtil(m,n,nums,i,j+1,dp);
        
        
        dp[i][j]=currVal+Math.min(down,right);
        
        return dp[i][j];
        
        
    }
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*************************************
Solution 3: Tabulation
*************************************

***********************************************************************************************************************************************************

Time Complexity: O(N*M)
Space Complexity: O(N*M)

***********************************************************************************************************************************************************


class Solution {
    public int minPathSum(int[][] grid) {
        
   
        int m=grid.length;
        int n=grid[0].length;
        
        int dp[][]=new int[m][n];
        
       
        for(int i=m-1;i>=0;i--){
            
            for(int j=n-1;j>=0;j--){
                
                if(i==m-1 && j==n-1){
                    dp[i][j]=grid[i][j];
                }else{
                    
                    int down=Integer.MAX_VALUE;
                    int right=Integer.MAX_VALUE;
                    
                    if(i+1<m){
                       down=dp[i+1][j]; 
                    }
                    
                    if(j+1<n){
                       right=dp[i][j+1]; 
                    }
                    
                    dp[i][j]=grid[i][j]+Math.min(down,right);
                }
            }
        }
        
        return dp[0][0];
    }
    
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

*****************************************
Solution 4: Tabulation - Space Optimmized
*****************************************

***********************************************************************************************************************************************************



***********************************************************************************************************************************************************
